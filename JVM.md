





## 二：JVM内存

**2.1 JVM哪些区域是线程私有的，哪些区域是线程共享的？**

1、堆、元空间（方法区）是线程共享的

2、其他区域是线程私有的



**2.2  JVM运行时数据区：程序计数器的特点及作用**

1、程序计数器是一块很小的内存空间，几乎可以忽略

2、是当前线程所执行的字节码的行号指示器

3、Java多线程执行时，每条线程都有一个独立的程序计数器，各条线程之间计数器互不影响

4、该区域是“线程私有”的内存，每个线程独立存储

5、该区域不存在OutOfMemoryError

6、无GC回收



**2.3 JVM运行时数据区：虚拟机栈的特点及作用**

1、线程私有

2、方法执行会创建栈帧，存储局部变量表等信息

3、方法执行入虚拟机栈，方法执行完出虚拟机栈

4、栈深度大于虚拟机所允许的时报错：StackOverflowError

5、栈需扩展而无法申请空间报错：OutOfMemoryError（比较少见）；hotspot虚拟机没有；

6、栈里面运行方法，存放方法的局部变量名，变量名所指向的值(常量值、对象值等)堆存放在堆上的

7、栈一般都不设置大小，栈所占的空间其实很小，可以通过-Xss1M进行设置，如果不设置默认为1M

8、随线程而生，随线程而灭

9、该区域不会有GC回收



**2.4  JVM运行时数据区：本地方法栈的特点及作用**

1、与虚拟机栈基本类似

2、区别在于本地方法栈为Native方法服务

3、HotSpot虚拟机将虚拟机栈和本地方法栈合并

4、有StackOverflowError和OutOfMemoryError（比较少见）

5、随线程而生，随线程而灭

6、GC不会回收该区域



**2.5 堆的特点及作用**

1、线程共享的一块区域

2、虚拟机启动时创建

3、虚拟机所管理的内存中最大的一块区域

4、存放所有实例对象或数组

5、GC垃圾收集器的主要管理区域

6、分新生代和老年代

7、新生代更细化为Eden、From Survivor、To Survivor。Eden：Survivor = 8：1：1

8、可通过JVM参数设置堆大小等信息，-Xmx、-Xms

-Xms 最小堆的大小， 也就是当你的虚拟机启动后， 就会分配这么大的堆内存给你 
-Xmx 是最大堆的大小 

当最小堆占满后，会尝试进行GC，如果GC之后还不能得到足够的内存(GC未必会收集到所有当前可用内存)，分配新的对象，那么就会扩展堆，如果-Xmx设置的太小，扩展堆就会失败，导致OutOfMemoryError错误提示。
9、无法扩展堆内存时报错：java.lang.OutOfMemoryError: Java heap space

10、如果从分配的内存角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。



**2.10 JVM中对象如何在堆内存分配？**

1、**指针碰撞**（Bump The Pointer）：内存规整的情况下

2、**空闲列表**（Free List）：内存不规整的情况下

选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有**空间压缩整理（Compact）的能力**决定

因此，当使用**Serial、ParNew**等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效。

而当使用**CMS**这种基于清除（Swap）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。

3、**本地线程分配缓存**（TLAB）：对象创建在虚拟机中频繁发生，即使仅仅修改一个指针所指向的位置，在并非情况下也并不是线程安全的。可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。

JVM提供两种解决方案：

（1）同步锁定，JVM是采用**CAS配上失败重试的方式**更新操作的原子性。

（2）线程隔离，把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区（TLAB），

哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓冲区时才同步锁定，**虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定**。通过参数 -XX：TLABSize=512K设置大小。



**2.11 查看JVM设置的参数大小的命令**

java -XX：+PrintFlagsFinal



**2.12JVM堆内存中的对象布局**

在HotSpot虚拟机中，一个对象的存储结构分为3个区域：**对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）**；

对象头（Header）：包含两部分，**第一部分用于存储对象自身的运行数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等**，32位虚拟机占32位，64位虚拟机占64位;官方称为”Mark Word“；
